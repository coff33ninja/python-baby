<?xml version="1.0" encoding="utf-8"?><testsuites><testsuite name="pytest" errors="0" failures="18" skipped="0" tests="34" time="157.936" timestamp="2025-05-25T21:28:41.775464+02:00" hostname="KUSANAGI"><testcase classname="tests.test_evaluate_secure_executor" name="test_execute_simple_pass" time="10.792"><failure message="AssertionError: Test should pass. Log: Execution process 21404 ended unexpectedly (exit code: 1) without returning results via queue., Stdout: , Stderr: Process Error (exit code 1)&#10;assert False is True">@pytest.mark.smoke
    def test_execute_simple_pass():
        test_logger.info("Starting test_execute_simple_pass")
        code = "x = 10\ny = 20\nresult = x + y"
        tests = "assert result == 30, f'Expected 30, got {result}'"
        executor = SecureExecutor(timeout_seconds=DEFAULT_TEST_TIMEOUT)
        passed, log, stdout, stderr = executor.execute(code, tests)
    
        print(f"Log: {log}")
        print(f"Stdout: {stdout}")
        print(f"Stderr: {stderr}")
    
&gt;       assert (
            passed is True
        ), f"Test should pass. Log: {log}, Stdout: {stdout}, Stderr: {stderr}"
E       AssertionError: Test should pass. Log: Execution process 21404 ended unexpectedly (exit code: 1) without returning results via queue., Stdout: , Stderr: Process Error (exit code 1)
E       assert False is True

tests\test_evaluate_secure_executor.py:26: AssertionError</failure></testcase><testcase classname="tests.test_evaluate_secure_executor" name="test_execute_assertion_fail" time="10.377"><failure message="AssertionError: Log or stderr should indicate AssertionError&#10;assert ('assertionerror' in 'execution process 54676 ended unexpectedly (exit code: 1) without returning results via queue.' or 'assertionerror' in 'process error (exit code 1)')&#10; +  where 'execution process 54676 ended unexpectedly (exit code: 1) without returning results via queue.' = &lt;built-in method lower of str object at 0x00000205E3984150&gt;()&#10; +    where &lt;built-in method lower of str object at 0x00000205E3984150&gt; = 'Execution process 54676 ended unexpectedly (exit code: 1) without returning results via queue.'.lower&#10; +  and   'process error (exit code 1)' = &lt;built-in method lower of str object at 0x00000205E3989520&gt;()&#10; +    where &lt;built-in method lower of str object at 0x00000205E3989520&gt; = 'Process Error (exit code 1)'.lower">def test_execute_assertion_fail():
        code = "x = 10"
        tests = "assert x == 20, 'x should be 20'"  # Add assert message for clarity
        executor = SecureExecutor(timeout_seconds=DEFAULT_TEST_TIMEOUT)
        passed, log, stdout, stderr = executor.execute(code, tests)
    
        print(f"Log: {log}")
        print(f"Stdout: {stdout}")
        print(f"Stderr: {stderr}")
    
        assert passed is False, f"Test should fail. Log: {log}"
&gt;       assert (
            "assertionerror" in log.lower() or "assertionerror" in stderr.lower()
        ), "Log or stderr should indicate AssertionError"
E       AssertionError: Log or stderr should indicate AssertionError
E       assert ('assertionerror' in 'execution process 54676 ended unexpectedly (exit code: 1) without returning results via queue.' or 'assertionerror' in 'process error (exit code 1)')
E        +  where 'execution process 54676 ended unexpectedly (exit code: 1) without returning results via queue.' = &lt;built-in method lower of str object at 0x00000205E3984150&gt;()
E        +    where &lt;built-in method lower of str object at 0x00000205E3984150&gt; = 'Execution process 54676 ended unexpectedly (exit code: 1) without returning results via queue.'.lower
E        +  and   'process error (exit code 1)' = &lt;built-in method lower of str object at 0x00000205E3989520&gt;()
E        +    where &lt;built-in method lower of str object at 0x00000205E3989520&gt; = 'Process Error (exit code 1)'.lower

tests\test_evaluate_secure_executor.py:44: AssertionError</failure></testcase><testcase classname="tests.test_evaluate_secure_executor" name="test_execute_restricted_import_os" time="10.225"><failure message="AssertionError: Expected SyntaxError or NameError due to restricted import. Log: Execution process 56448 ended unexpectedly (exit code: 1) without returning results via queue., Stderr: Process Error (exit code 1)&#10;assert ('syntaxerror' in 'execution process 56448 ended unexpectedly (exit code: 1) without returning results via queue.' or 'nameerror' in 'execution process 56448 ended unexpectedly (exit code: 1) without returning results via queue.' or 'syntaxerror' in 'process error (exit code 1)' or 'nameerror' in 'process error (exit code 1)')&#10; +  where 'execution process 56448 ended unexpectedly (exit code: 1) without returning results via queue.' = &lt;built-in method lower of str object at 0x00000205E38F6D30&gt;()&#10; +    where &lt;built-in method lower of str object at 0x00000205E38F6D30&gt; = 'Execution process 56448 ended unexpectedly (exit code: 1) without returning results via queue.'.lower&#10; +  and   'execution process 56448 ended unexpectedly (exit code: 1) without returning results via queue.' = &lt;built-in method lower of str object at 0x00000205E38F6D30&gt;()&#10; +    where &lt;built-in method lower of str object at 0x00000205E38F6D30&gt; = 'Execution process 56448 ended unexpectedly (exit code: 1) without returning results via queue.'.lower&#10; +  and   'process error (exit code 1)' = &lt;built-in method lower of str object at 0x00000205E398AA10&gt;()&#10; +    where &lt;built-in method lower of str object at 0x00000205E398AA10&gt; = 'Process Error (exit code 1)'.lower&#10; +  and   'process error (exit code 1)' = &lt;built-in method lower of str object at 0x00000205E398AA10&gt;()&#10; +    where &lt;built-in method lower of str object at 0x00000205E398AA10&gt; = 'Process Error (exit code 1)'.lower">caplog = &lt;_pytest.logging.LogCaptureFixture object at 0x00000205E3CA4210&gt;

    def test_execute_restricted_import_os(caplog):
        code = "import os\nprint(os.getcwd())"  # Attempting to use os
        tests = "assert True"  # Test itself is trivial
        executor = SecureExecutor(timeout_seconds=DEFAULT_TEST_TIMEOUT)
    
        # caplog.set_level(logging.DEBUG) # If SecureExecutor or RestrictedPython logs verbosely
    
        passed, log, stdout, stderr = executor.execute(code, tests)
    
        print(f"Log: {log}")
        print(f"Stdout: {stdout}")
        print(f"Stderr: {stderr}")
    
        assert passed is False, "Execution should fail due to restricted import."
        # RestrictedPython typically raises a NameError for disallowed imports at compile/exec time,
        # if 'os' is not handled by safe_globals or a custom importer.
        # The log in evaluate.py will capture this as "Execution error: SyntaxError: ..."
        # If the code were `print(os.getcwd())` without `import os`, it would be a NameError.
&gt;       assert (
            "syntaxerror" in log.lower()
            or "nameerror" in log.lower()
            or "syntaxerror" in stderr.lower()
            or "nameerror" in stderr.lower()
        ), f"Expected SyntaxError or NameError due to restricted import. Log: {log}, Stderr: {stderr}"
E       AssertionError: Expected SyntaxError or NameError due to restricted import. Log: Execution process 56448 ended unexpectedly (exit code: 1) without returning results via queue., Stderr: Process Error (exit code 1)
E       assert ('syntaxerror' in 'execution process 56448 ended unexpectedly (exit code: 1) without returning results via queue.' or 'nameerror' in 'execution process 56448 ended unexpectedly (exit code: 1) without returning results via queue.' or 'syntaxerror' in 'process error (exit code 1)' or 'nameerror' in 'process error (exit code 1)')
E        +  where 'execution process 56448 ended unexpectedly (exit code: 1) without returning results via queue.' = &lt;built-in method lower of str object at 0x00000205E38F6D30&gt;()
E        +    where &lt;built-in method lower of str object at 0x00000205E38F6D30&gt; = 'Execution process 56448 ended unexpectedly (exit code: 1) without returning results via queue.'.lower
E        +  and   'execution process 56448 ended unexpectedly (exit code: 1) without returning results via queue.' = &lt;built-in method lower of str object at 0x00000205E38F6D30&gt;()
E        +    where &lt;built-in method lower of str object at 0x00000205E38F6D30&gt; = 'Execution process 56448 ended unexpectedly (exit code: 1) without returning results via queue.'.lower
E        +  and   'process error (exit code 1)' = &lt;built-in method lower of str object at 0x00000205E398AA10&gt;()
E        +    where &lt;built-in method lower of str object at 0x00000205E398AA10&gt; = 'Process Error (exit code 1)'.lower
E        +  and   'process error (exit code 1)' = &lt;built-in method lower of str object at 0x00000205E398AA10&gt;()
E        +    where &lt;built-in method lower of str object at 0x00000205E398AA10&gt; = 'Process Error (exit code 1)'.lower

tests\test_evaluate_secure_executor.py:70: AssertionError</failure></testcase><testcase classname="tests.test_evaluate_secure_executor" name="test_execute_infinite_loop_timeout" time="3.028" /><testcase classname="tests.test_evaluate_secure_executor" name="test_execute_sandboxed_code_cannot_access_host_variables" time="10.288"><failure message="AssertionError: Log or stderr should indicate a NameError.&#10;assert ('nameerror' in 'execution process 17084 ended unexpectedly (exit code: 1) without returning results via queue.' or 'nameerror' in 'process error (exit code 1)')&#10; +  where 'execution process 17084 ended unexpectedly (exit code: 1) without returning results via queue.' = &lt;built-in method lower of str object at 0x00000205E3984B70&gt;()&#10; +    where &lt;built-in method lower of str object at 0x00000205E3984B70&gt; = 'Execution process 17084 ended unexpectedly (exit code: 1) without returning results via queue.'.lower&#10; +  and   'process error (exit code 1)' = &lt;built-in method lower of str object at 0x00000205E39884E0&gt;()&#10; +    where &lt;built-in method lower of str object at 0x00000205E39884E0&gt; = 'Process Error (exit code 1)'.lower">def test_execute_sandboxed_code_cannot_access_host_variables():
        """
        Tests that code executed by SecureExecutor cannot access variables
        from the host Python environment (e.g., the test function's scope).
        """
        host_variable = "sensitive_data_from_host_environment"
    
        # Attempt to print the host_variable from within the sandboxed code.
        # This should fail with a NameError.
        code = f"print({host_variable})" # Intentionally try to access undefined variable
        tests = "assert True"  # Test string is trivial for this scenario
    
        executor = SecureExecutor(timeout_seconds=DEFAULT_TEST_TIMEOUT)
        passed, log, stdout, stderr = executor.execute(code, tests)
    
        print(f"Log: {log}")
        print(f"Stdout: {stdout}")
        print(f"Stderr: {stderr}")
    
        assert passed is False, "Execution should fail due to trying to access an undefined (host) variable."
&gt;       assert "nameerror" in log.lower() or "nameerror" in stderr.lower(), \
            "Log or stderr should indicate a NameError."
E       AssertionError: Log or stderr should indicate a NameError.
E       assert ('nameerror' in 'execution process 17084 ended unexpectedly (exit code: 1) without returning results via queue.' or 'nameerror' in 'process error (exit code 1)')
E        +  where 'execution process 17084 ended unexpectedly (exit code: 1) without returning results via queue.' = &lt;built-in method lower of str object at 0x00000205E3984B70&gt;()
E        +    where &lt;built-in method lower of str object at 0x00000205E3984B70&gt; = 'Execution process 17084 ended unexpectedly (exit code: 1) without returning results via queue.'.lower
E        +  and   'process error (exit code 1)' = &lt;built-in method lower of str object at 0x00000205E39884E0&gt;()
E        +    where &lt;built-in method lower of str object at 0x00000205E39884E0&gt; = 'Process Error (exit code 1)'.lower

tests\test_evaluate_secure_executor.py:125: AssertionError</failure></testcase><testcase classname="tests.test_evaluate_secure_executor" name="test_execute_print_capture" time="10.307"><failure message="AssertionError: Test should pass. Log: Execution process 57592 ended unexpectedly (exit code: 1) without returning results via queue., Stderr: Process Error (exit code 1)&#10;assert False is True">def test_execute_print_capture():
        code = "print('Hello from sandbox')\nprint('Line 2')\nvar = 'done'"
        tests = "assert var == 'done'"  # Ensure main code runs
        executor = SecureExecutor(timeout_seconds=DEFAULT_TEST_TIMEOUT)
        passed, log, stdout, stderr = executor.execute(code, tests)
    
        print(f"Log: {log}")
        print(f"Stdout: {stdout}")
        print(f"Stderr: {stderr}")
    
&gt;       assert passed is True, f"Test should pass. Log: {log}, Stderr: {stderr}"
E       AssertionError: Test should pass. Log: Execution process 57592 ended unexpectedly (exit code: 1) without returning results via queue., Stderr: Process Error (exit code 1)
E       assert False is True

tests\test_evaluate_secure_executor.py:141: AssertionError</failure></testcase><testcase classname="tests.test_evaluate_secure_executor" name="test_execute_syntax_error_in_generated_code" time="10.473"><failure message="AssertionError: assert ('syntaxerror' in 'execution process 47652 ended unexpectedly (exit code: 1) without returning results via queue.' or 'syntaxerror' in 'process error (exit code 1)')&#10; +  where 'execution process 47652 ended unexpectedly (exit code: 1) without returning results via queue.' = &lt;built-in method lower of str object at 0x00000205E39846F0&gt;()&#10; +    where &lt;built-in method lower of str object at 0x00000205E39846F0&gt; = 'Execution process 47652 ended unexpectedly (exit code: 1) without returning results via queue.'.lower&#10; +  and   'process error (exit code 1)' = &lt;built-in method lower of str object at 0x00000205E398A1A0&gt;()&#10; +    where &lt;built-in method lower of str object at 0x00000205E398A1A0&gt; = 'Process Error (exit code 1)'.lower">def test_execute_syntax_error_in_generated_code():
        code = "x = 10\ny = 20 +\nresult = x + y"  # Syntax error
        tests = "assert True"
        executor = SecureExecutor(timeout_seconds=DEFAULT_TEST_TIMEOUT)
        passed, log, stdout, stderr = executor.execute(code, tests)
    
        print(f"Log: {log}")
        print(f"Stdout: {stdout}")
        print(f"Stderr: {stderr}")
    
        assert passed is False
&gt;       assert "syntaxerror" in log.lower() or "syntaxerror" in stderr.lower()
E       AssertionError: assert ('syntaxerror' in 'execution process 47652 ended unexpectedly (exit code: 1) without returning results via queue.' or 'syntaxerror' in 'process error (exit code 1)')
E        +  where 'execution process 47652 ended unexpectedly (exit code: 1) without returning results via queue.' = &lt;built-in method lower of str object at 0x00000205E39846F0&gt;()
E        +    where &lt;built-in method lower of str object at 0x00000205E39846F0&gt; = 'Execution process 47652 ended unexpectedly (exit code: 1) without returning results via queue.'.lower
E        +  and   'process error (exit code 1)' = &lt;built-in method lower of str object at 0x00000205E398A1A0&gt;()
E        +    where &lt;built-in method lower of str object at 0x00000205E398A1A0&gt; = 'Process Error (exit code 1)'.lower

tests\test_evaluate_secure_executor.py:161: AssertionError</failure></testcase><testcase classname="tests.test_evaluate_secure_executor" name="test_execute_runtime_error_in_generated_code" time="10.273"><failure message="AssertionError: assert ('zerodivisionerror' in 'execution process 57420 ended unexpectedly (exit code: 1) without returning results via queue.' or 'zerodivisionerror' in 'process error (exit code 1)')&#10; +  where 'execution process 57420 ended unexpectedly (exit code: 1) without returning results via queue.' = &lt;built-in method lower of str object at 0x00000205E39853E0&gt;()&#10; +    where &lt;built-in method lower of str object at 0x00000205E39853E0&gt; = 'Execution process 57420 ended unexpectedly (exit code: 1) without returning results via queue.'.lower&#10; +  and   'process error (exit code 1)' = &lt;built-in method lower of str object at 0x00000205E398BD20&gt;()&#10; +    where &lt;built-in method lower of str object at 0x00000205E398BD20&gt; = 'Process Error (exit code 1)'.lower">def test_execute_runtime_error_in_generated_code():
        code = "x = 10\nresult = x / 0"  # Runtime error (ZeroDivisionError)
        tests = "assert True"
        executor = SecureExecutor(timeout_seconds=DEFAULT_TEST_TIMEOUT)
        passed, log, stdout, stderr = executor.execute(code, tests)
    
        print(f"Log: {log}")
        print(f"Stdout: {stdout}")
        print(f"Stderr: {stderr}")
    
        assert passed is False
&gt;       assert "zerodivisionerror" in log.lower() or "zerodivisionerror" in stderr.lower()
E       AssertionError: assert ('zerodivisionerror' in 'execution process 57420 ended unexpectedly (exit code: 1) without returning results via queue.' or 'zerodivisionerror' in 'process error (exit code 1)')
E        +  where 'execution process 57420 ended unexpectedly (exit code: 1) without returning results via queue.' = &lt;built-in method lower of str object at 0x00000205E39853E0&gt;()
E        +    where &lt;built-in method lower of str object at 0x00000205E39853E0&gt; = 'Execution process 57420 ended unexpectedly (exit code: 1) without returning results via queue.'.lower
E        +  and   'process error (exit code 1)' = &lt;built-in method lower of str object at 0x00000205E398BD20&gt;()
E        +    where &lt;built-in method lower of str object at 0x00000205E398BD20&gt; = 'Process Error (exit code 1)'.lower

tests\test_evaluate_secure_executor.py:175: AssertionError</failure></testcase><testcase classname="tests.test_evaluate_secure_executor" name="test_execute_empty_code_and_tests" time="10.308"><failure message="assert False is True">def test_execute_empty_code_and_tests():
        code = ""
        tests = ""
        executor = SecureExecutor(timeout_seconds=DEFAULT_TEST_TIMEOUT)
        passed, log, stdout, stderr = executor.execute(code, tests)
    
        print(f"Log: {log}")
        print(f"Stdout: {stdout}")
        print(f"Stderr: {stderr}")
    
&gt;       assert passed is True  # Empty code and tests should "pass" (no errors)
E       assert False is True

tests\test_evaluate_secure_executor.py:188: AssertionError</failure></testcase><testcase classname="tests.test_evaluate_secure_executor" name="test_execute_code_modifying_restricted_globals_fails_safely" time="10.225"><failure message="AssertionError: Test should pass as the overwrite of 'len' is contained in its scope.&#10;assert False is True">def test_execute_code_modifying_restricted_globals_fails_safely():
        # This test's behavior depends heavily on the strictness of _write_ guard.
        # The current basic _write_ = lambda x: x guard might allow this.
        # A stricter guard like full_write_guard would make this fail.
        # For now, we test based on the current (more permissive) setup.
        code = "len = lambda x: 'modified_len'"  # Attempt to modify a builtin in restricted_globals
        tests = (
            "assert len([]) == 0"  # This would fail if 'len' was successfully overwritten
        )
    
        executor = SecureExecutor(timeout_seconds=DEFAULT_TEST_TIMEOUT)
        passed, log, stdout, stderr = executor.execute(code, tests)
    
        print(f"Log: {log}")
        print(f"Stdout: {stdout}")
        print(f"Stderr: {stderr}")
    
        # The assignment `len = ...` in the `code` string creates a local variable `len`
        # within that execution's scope due to RestrictedPython's handling and the current
        # permissive `_write_` guard in evaluate.py (`_write_ = lambda x: x`).
        # This local `len` does not override the builtin `len` available to the
        # `tests_string` execution context, which still resolves to the `len` from
        # `safe_globals['__builtins__']`. Thus, the assertion uses the original `len`.
&gt;       assert (
            passed is True
        ), "Test should pass as the overwrite of 'len' is contained in its scope."
E       AssertionError: Test should pass as the overwrite of 'len' is contained in its scope.
E       assert False is True

tests\test_evaluate_secure_executor.py:215: AssertionError</failure></testcase><testcase classname="tests.test_evaluate_secure_executor" name="test_execute_malformed_test_string_syntax_error" time="10.308"><failure message="AssertionError: Log or stderr should indicate SyntaxError.&#10;assert ('syntaxerror' in 'execution process 28000 ended unexpectedly (exit code: 1) without returning results via queue.' or 'syntaxerror' in 'process error (exit code 1)')&#10; +  where 'execution process 28000 ended unexpectedly (exit code: 1) without returning results via queue.' = &lt;built-in method lower of str object at 0x00000205E3984E40&gt;()&#10; +    where &lt;built-in method lower of str object at 0x00000205E3984E40&gt; = 'Execution process 28000 ended unexpectedly (exit code: 1) without returning results via queue.'.lower&#10; +  and   'process error (exit code 1)' = &lt;built-in method lower of str object at 0x00000205E3988A80&gt;()&#10; +    where &lt;built-in method lower of str object at 0x00000205E3988A80&gt; = 'Process Error (exit code 1)'.lower">def test_execute_malformed_test_string_syntax_error():
        code = "x = 10"
        tests = "assert x =="  # Syntax error in test string
        executor = SecureExecutor(timeout_seconds=DEFAULT_TEST_TIMEOUT)
        passed, log, stdout, stderr = executor.execute(code, tests)
    
        print(f"Log: {log}")
        print(f"Stdout: {stdout}")
        print(f"Stderr: {stderr}")
    
        assert passed is False, "Execution should fail due to syntax error in test string."
&gt;       assert (
            "syntaxerror" in log.lower() or "syntaxerror" in stderr.lower()
        ), "Log or stderr should indicate SyntaxError."
E       AssertionError: Log or stderr should indicate SyntaxError.
E       assert ('syntaxerror' in 'execution process 28000 ended unexpectedly (exit code: 1) without returning results via queue.' or 'syntaxerror' in 'process error (exit code 1)')
E        +  where 'execution process 28000 ended unexpectedly (exit code: 1) without returning results via queue.' = &lt;built-in method lower of str object at 0x00000205E3984E40&gt;()
E        +    where &lt;built-in method lower of str object at 0x00000205E3984E40&gt; = 'Execution process 28000 ended unexpectedly (exit code: 1) without returning results via queue.'.lower
E        +  and   'process error (exit code 1)' = &lt;built-in method lower of str object at 0x00000205E3988A80&gt;()
E        +    where &lt;built-in method lower of str object at 0x00000205E3988A80&gt; = 'Process Error (exit code 1)'.lower

tests\test_evaluate_secure_executor.py:235: AssertionError</failure></testcase><testcase classname="tests.test_evaluate_secure_executor" name="test_execute_very_large_code_string_basic_pass" time="10.299"><failure message="AssertionError: Execution with large code string should pass. Log: Execution process 56852 ended unexpectedly (exit code: 1) without returning results via queue., Stderr: Process Error (exit code 1)&#10;assert False is True">def test_execute_very_large_code_string_basic_pass():
        # Simple test to ensure basic handling of large code string, not for performance.
        # RestrictedPython or the system might have its own limits.
        # Create a long series of simple assignments.
        num_assignments = (
            500  # Reduced from a very large number to keep test reasonably fast
        )
        code_lines = [f"var_{i} = {i}" for i in range(num_assignments)]
        code = "\n".join(code_lines) + f"\nfinal_result = var_{num_assignments-1}"
        tests = f"assert final_result == {num_assignments-1}"
    
        executor = SecureExecutor(
            timeout_seconds=DEFAULT_TEST_TIMEOUT + 5
        )  # Slightly longer timeout for larger code
        passed, log, stdout, stderr = executor.execute(code, tests)
    
&gt;       assert (
            passed is True
        ), f"Execution with large code string should pass. Log: {log}, Stderr: {stderr}"
E       AssertionError: Execution with large code string should pass. Log: Execution process 56852 ended unexpectedly (exit code: 1) without returning results via queue., Stderr: Process Error (exit code 1)
E       assert False is True

tests\test_evaluate_secure_executor.py:256: AssertionError</failure></testcase><testcase classname="tests.test_evaluate_secure_executor" name="test_long_output_capture" time="10.317"><failure message="assert False is True">caplog = &lt;_pytest.logging.LogCaptureFixture object at 0x00000205E3C554D0&gt;

    def test_long_output_capture(caplog):
        # Tests if large stdout/stderr are handled without crashing (though they might be truncated by other means)
        long_string = "a" * 2000
        code = f"print('{long_string}')"
        tests = "assert True"
        executor = SecureExecutor(timeout_seconds=DEFAULT_TEST_TIMEOUT)
        passed, log, stdout, stderr = executor.execute(code, tests)
    
&gt;       assert passed is True
E       assert False is True

tests\test_evaluate_secure_executor.py:273: AssertionError</failure></testcase><testcase classname="tests.test_grow" name="test_grow_model_no_growth_needed" time="2.012" /><testcase classname="tests.test_grow" name="test_grow_model_master_approval_network_failure" time="0.994" /><testcase classname="tests.test_grow" name="test_grow_model_master_approval_denied_status_code" time="1.029" /><testcase classname="tests.test_grow" name="test_grow_model_master_approval_denied_action" time="1.006" /><testcase classname="tests.test_grow" name="test_grow_model_success_with_existing_layers" time="11.835"><failure message="AssertionError: Parameter self_attn.in_proj_weight in new layer not scaled correctly.&#10;assert False&#10; +  where False = &lt;built-in method allclose of type object at 0x00007FFB63F92440&gt;(tensor([[-0.0348,  0.0189, -0.0133,  ...,  0.0316, -0.0117, -0.0042],\n        [ 0.0078,  0.0010, -0.0143,  ...,  0.0154, -0.0036, -0.0073],\n        [-0.0179,  0.0077,  0.0315,  ..., -0.0207,  0.0262, -0.0199],\n        ...,\n        [ 0.0308, -0.0221, -0.0323,  ..., -0.0165,  0.0187,  0.0232],\n        [-0.0220, -0.0082,  0.0074,  ..., -0.0187,  0.0175, -0.0256],\n        [ 0.0249, -0.0372, -0.0317,  ..., -0.0066,  0.0141,  0.0141]]), tensor([[ 0.0098, -0.0006, -0.0098,  ..., -0.0157, -0.0064,  0.0214],\n        [-0.0287, -0.0374,  0.0185,  ..., -0.0306, -0.0006,  0.0040],\n        [ 0.0183,  0.0309, -0.0228,  ..., -0.0308, -0.0279, -0.0039],\n        ...,\n        [-0.0125, -0.0189, -0.0170,  ..., -0.0013, -0.0340, -0.0069],\n        [ 0.0124, -0.0198, -0.0056,  ...,  0.0128, -0.0003,  0.0004],\n        [ 0.0289, -0.0140, -0.0099,  ...,  0.0311,  0.0261, -0.0342]]), atol=1e-07)&#10; +    where &lt;built-in method allclose of type object at 0x00007FFB63F92440&gt; = torch.allclose">mock_get_typed_config = &lt;MagicMock name='get_typed_config_value' id='2224276425872'&gt;, mock_update_stage_on_new_model = &lt;MagicMock name='update_stage' id='2224316924112'&gt;
base_model = PythonMasterAI(
  (embed): Embedding(16000, 256)
  (transformer): Transformer(
    (encoder): TransformerEncoder(
    ...((256,), eps=1e-05, elementwise_affine=True)
    )
  )
  (fc): Linear(in_features=256, out_features=16000, bias=True)
)
tmp_path = WindowsPath('C:/Users/DRAGOHN/AppData/Local/Temp/pytest-of-DRAGOHN/pytest-8/test_grow_model_success_with_e0')

    @patch('python_master_ai.PythonMasterAI.update_stage') # Patch at class level
    @patch('utils.get_typed_config_value') # To mock config access for checkpoint_dir
    def test_grow_model_success_with_existing_layers(mock_get_typed_config, mock_update_stage_on_new_model, base_model, tmp_path):
        """Test successful model growth when encoder has existing layers."""
        mock_response = mock_requests_post_response(status_code=200, json_data={"action": "grow"})
    
        # --- Arrange ---
        # Mock config for CHECKPOINT_DIR to use tmp_path
        mock_checkpoint_dir = tmp_path / "checkpoints"
        def config_side_effect(key, default=None, type_hint=None): # Match expected signature
            if key == "checkpointing.checkpoint_dir":
                return str(mock_checkpoint_dir)
            elif key == "training.growth_strategy_factor": # Used by grow_model
                return 2.0
            elif key == "training.growth_increment": # Used by grow_model
                return 1
            return default
        mock_get_typed_config.side_effect = config_side_effect
    
        with patch.object(base_model, 'assess_performance', return_value={"needs_growth": True}):
            with patch('grow.requests.post', return_value=mock_response) as mock_post:
                initial_n_layers = base_model.n_layers
                initial_model_config_id = base_model.configuration_id
                assert initial_n_layers &gt; 0, "Model should have initial layers for this test"
    
                last_layer_state_dict_from_old_model = copy.deepcopy(base_model.transformer.encoder.layers[-1].state_dict())
    
                grown_model_instance, optimizer = grow_model(base_model)
    
                assert grown_model_instance is not base_model # The new model is returned
                assert isinstance(optimizer, Adam)
                assert grown_model_instance.n_layers == initial_n_layers + 1 # Check new model
                assert grown_model_instance.configuration_id != initial_model_config_id
                assert len(grown_model_instance.transformer.encoder.layers) == initial_n_layers + 1 # Check new model
                mock_post.assert_called_once()
                mock_update_stage_on_new_model.assert_called_once() # update_stage is called on the new grown_model instance
    
                # Check scaling of the newly added layer (it's seeded from the old model's last layer)
                newly_added_layer_in_grown_model = grown_model_instance.transformer.encoder.layers[-1]
                for param_name, param_tensor_from_old_model_last_layer in last_layer_state_dict_from_old_model.items():
                    expected_tensor_after_scaling = param_tensor_from_old_model_last_layer * 0.5 # Scaling factor is 0.5
                    actual_tensor_in_new_layer = newly_added_layer_in_grown_model.state_dict()[param_name]
&gt;                   assert torch.allclose(actual_tensor_in_new_layer, expected_tensor_after_scaling, atol=1e-7), \
                        f"Parameter {param_name} in new layer not scaled correctly."
E                   AssertionError: Parameter self_attn.in_proj_weight in new layer not scaled correctly.
E                   assert False
E                    +  where False = &lt;built-in method allclose of type object at 0x00007FFB63F92440&gt;(tensor([[-0.0348,  0.0189, -0.0133,  ...,  0.0316, -0.0117, -0.0042],\n        [ 0.0078,  0.0010, -0.0143,  ...,  0.0154, -0.0036, -0.0073],\n        [-0.0179,  0.0077,  0.0315,  ..., -0.0207,  0.0262, -0.0199],\n        ...,\n        [ 0.0308, -0.0221, -0.0323,  ..., -0.0165,  0.0187,  0.0232],\n        [-0.0220, -0.0082,  0.0074,  ..., -0.0187,  0.0175, -0.0256],\n        [ 0.0249, -0.0372, -0.0317,  ..., -0.0066,  0.0141,  0.0141]]), tensor([[ 0.0098, -0.0006, -0.0098,  ..., -0.0157, -0.0064,  0.0214],\n        [-0.0287, -0.0374,  0.0185,  ..., -0.0306, -0.0006,  0.0040],\n        [ 0.0183,  0.0309, -0.0228,  ..., -0.0308, -0.0279, -0.0039],\n        ...,\n        [-0.0125, -0.0189, -0.0170,  ..., -0.0013, -0.0340, -0.0069],\n        [ 0.0124, -0.0198, -0.0056,  ...,  0.0128, -0.0003,  0.0004],\n        [ 0.0289, -0.0140, -0.0099,  ...,  0.0311,  0.0261, -0.0342]]), atol=1e-07)
E                    +    where &lt;built-in method allclose of type object at 0x00007FFB63F92440&gt; = torch.allclose

tests\test_grow.py:151: AssertionError</failure></testcase><testcase classname="tests.test_grow" name="test_grow_model_success_initially_no_layers_in_encoder" time="2.382"><failure message="AssertionError: Expected 'mock' to have been called once. Called 0 times.">mock_update_stage_on_new_model = &lt;MagicMock name='update_stage' id='2224420109776'&gt;
mock_torch_encoder_layer_constructor = &lt;MagicMock name='TransformerEncoderLayer' id='2224420103568'&gt;
mock_get_typed_config = &lt;MagicMock name='get_typed_config_value' id='2224420109456'&gt;
base_model = PythonMasterAI(
  (embed): Embedding(16000, 256)
  (transformer): Transformer(
    (encoder): TransformerEncoder(
    ...((256,), eps=1e-05, elementwise_affine=True)
    )
  )
  (fc): Linear(in_features=256, out_features=16000, bias=True)
)
tmp_path = WindowsPath('C:/Users/DRAGOHN/AppData/Local/Temp/pytest-of-DRAGOHN/pytest-8/test_grow_model_success_initia0')

    @patch('utils.get_typed_config_value') # To mock config access for checkpoint_dir
    @patch('torch.nn.modules.transformer.TransformerEncoderLayer')
    @patch('python_master_ai.PythonMasterAI.update_stage')
    def test_grow_model_success_initially_no_layers_in_encoder(mock_update_stage_on_new_model, mock_torch_encoder_layer_constructor, mock_get_typed_config, base_model, tmp_path):
        """Test successful growth when encoder initially has no layers (testing the 'if old_layers:' branch)."""
        # --- Arrange ---
        # Replace the ModuleList with a new empty one.
        # PyTorch's nn.Module handles reassignment of nn.Module attributes by updating _modules.
        # Mock config for CHECKPOINT_DIR to use tmp_path
        mock_checkpoint_dir = tmp_path / "checkpoints"
        def config_side_effect(key, default=None, type_hint=None): # Match expected signature
            if key == "checkpointing.checkpoint_dir":
                return str(mock_checkpoint_dir)
            elif key == "training.growth_strategy_factor": return 2.0
            elif key == "training.growth_increment": return 1
            return default
        mock_get_typed_config.side_effect = config_side_effect
    
        base_model.transformer.encoder.layers = nn.ModuleList()
        # Set the model's n_layers attribute to 0 to reflect that we want to test the "no initial layers" state
        base_model.n_layers = 0
        initial_n_layers_attr = base_model.n_layers # This will now be 0
    
        # Make the mock_torch_encoder_layer_constructor (which replaces the class) behave like a type for isinstance
        # and ensure it's callable to return our mock instance.
        mock_torch_encoder_layer_constructor.__bases__ = (torch.nn.TransformerEncoderLayer,) # Make the mock class a "subclass"
    
        # Configure the mock constructor to return an instance of our nn.Module mock
        # This instance will have its own 'parameters' MagicMock method.
        # This is the actual nn.Module instance that will be added to the model
        actual_module_instance = MockEncoderLayerModule( # As per the prompt's refined version
            d_model=base_model.hidden_size,
            nhead=base_model.n_heads,
            dim_feedforward=base_model.dim_feedforward,
            dropout=base_model.dropout,
            activation=base_model.activation,
            batch_first=True
        )
        mock_torch_encoder_layer_constructor.return_value = actual_module_instance
        # We need to mock the 'named_parameters' *method* of this specific instance.
        # Adam optimizer calls model.parameters(), which internally calls named_parameters() recursively.
        mock_named_parameters_method = MagicMock(name="named_parameters_method_mock")
    
        # Configure what this mocked 'named_parameters' method will return
        # (an iterator of (name, mock nn.Parameter) tuples)
        mock_param1 = MagicMock(spec=nn.Parameter) # Mock an nn.Parameter
        mock_param1.requires_grad = True # Optimizers usually only care about params that require grad
        mock_param2 = MagicMock(spec=nn.Parameter) # Mock another nn.Parameter
        mock_param2.requires_grad = True
        # As per the prompt's refined version, mock parameters() directly
        actual_module_instance.parameters = MagicMock(return_value=iter([mock_param1, mock_param2]))
    
        mock_response = mock_requests_post_response(status_code=200, json_data={"action": "grow"})
        initial_model_config_id = base_model.configuration_id
    
        with patch.object(base_model, 'assess_performance', return_value={"needs_growth": True}):
            with patch('grow.requests.post', return_value=mock_response) as mock_post:
                # --- Act ---
                grown_model_instance, optimizer = grow_model(base_model)
    
                # --- Assert ---
                assert grown_model_instance is not base_model
                assert isinstance(optimizer, Adam)
                assert grown_model_instance.n_layers == initial_n_layers_attr + 1
                assert len(grown_model_instance.transformer.encoder.layers) == 1 # One new layer added
                # The TransformerEncoder uses copy.deepcopy(encoder_layer), so we can't use 'is'.
                # Instead, check the type and that the (deepcopied) mocked 'parameters' method was called.
                added_layer = grown_model_instance.transformer.encoder.layers[0]
                assert isinstance(added_layer, MockEncoderLayerModule), \
                "Layer added is not of the expected mock type MockEncoderLayerModule."
    
                # The 'named_parameters' attribute of actual_module_instance was replaced by mock_named_parameters_method.
                # When deepcopied, added_layer.named_parameters becomes a deepcopy of mock_named_parameters_method.
                # This deepcopied mock should have been called by the Adam optimizer.
                # As per the prompt's refined version, assert parameters() was called
&gt;               added_layer.parameters.assert_called_once()

tests\test_grow.py:240: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;MagicMock id='2224437539920'&gt;

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
&gt;           raise AssertionError(msg)
E           AssertionError: Expected 'mock' to have been called once. Called 0 times.

C:\Python311\Lib\unittest\mock.py:918: AssertionError</failure></testcase><testcase classname="tests.test_grow" name="test_grow_model_optimizer_creation_failure" time="2.107"><failure message="Exception: Optimizer creation failed">mock_post = &lt;MagicMock name='post' id='2224419811024'&gt;, mock_adam = &lt;MagicMock name='Adam' id='2224419810064'&gt;
mock_get_typed_config = &lt;MagicMock name='get_typed_config_value' id='2224419810896'&gt;, mock_update_stage = &lt;MagicMock name='update_stage' id='2224420031760'&gt;
base_model = PythonMasterAI(
  (embed): Embedding(16000, 256)
  (transformer): Transformer(
    (encoder): TransformerEncoder(
    ...((256,), eps=1e-05, elementwise_affine=True)
    )
  )
  (fc): Linear(in_features=256, out_features=16000, bias=True)
)
tmp_path = WindowsPath('C:/Users/DRAGOHN/AppData/Local/Temp/pytest-of-DRAGOHN/pytest-8/test_grow_model_optimizer_crea0')

    @patch('python_master_ai.PythonMasterAI.update_stage')
    @patch('utils.get_typed_config_value')
    @patch('grow.Adam') # Mock torch.optim.Adam as imported in grow.py
    @patch('grow.requests.post')
    def test_grow_model_optimizer_creation_failure(
        mock_post, mock_adam, mock_get_typed_config, mock_update_stage, base_model, tmp_path
    ):
        """Test that grow_model handles failure during optimizer creation gracefully."""
        # --- Arrange ---
        # Mock master server approval
        mock_post.return_value = mock_requests_post_response(status_code=200, json_data={"action": "grow"})
    
        # Mock assess_performance to trigger growth
        base_model.assess_performance = MagicMock(return_value={"needs_growth": True})
    
        # Configure mock_get_typed_config for checkpoint_dir and other grow_model needs
        mock_checkpoint_dir = tmp_path / "checkpoints"
        def config_side_effect(key, default=None, type_hint=None):
            if key == "checkpointing.checkpoint_dir":
                return str(mock_checkpoint_dir)
            elif key == "training.growth_strategy_factor": return 2.0
            elif key == "training.growth_increment": return 1
            return default
        mock_get_typed_config.side_effect = config_side_effect
    
        # Simulate optimizer creation failure
        mock_adam.side_effect = Exception("Optimizer creation failed")
    
        # --- Act ---
&gt;       grown_model, grown_optimizer = grow_model(base_model)

tests\test_grow.py:301: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
grow.py:114: in grow_model
    new_optimizer = Adam(grown_model.parameters(), lr=default_lr)
C:\Python311\Lib\unittest\mock.py:1124: in __call__
    return self._mock_call(*args, **kwargs)
C:\Python311\Lib\unittest\mock.py:1128: in _mock_call
    return self._execute_mock_call(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;MagicMock name='Adam' id='2224419810064'&gt;, args = (&lt;generator object Module.parameters at 0x00000205E3D1F840&gt;,), kwargs = {'lr': 0.0001}
effect = Exception('Optimizer creation failed')

    def _execute_mock_call(self, /, *args, **kwargs):
        # separate from _increment_mock_call so that awaited functions are
        # executed separately from their call, also AsyncMock overrides this method
    
        effect = self.side_effect
        if effect is not None:
            if _is_exception(effect):
&gt;               raise effect
E               Exception: Optimizer creation failed

C:\Python311\Lib\unittest\mock.py:1183: Exception</failure></testcase><testcase classname="tests.test_utils" name="test_load_valid_config" time="0.006" /><testcase classname="tests.test_utils" name="test_get_nested_value" time="0.006" /><testcase classname="tests.test_utils" name="test_get_missing_key_with_default" time="0.005" /><testcase classname="tests.test_utils" name="test_config_file_not_found" time="0.002" /><testcase classname="tests.test_utils" name="test_invalid_yaml_config" time="0.006" /><testcase classname="tests.test_utils" name="test_empty_yaml_config" time="0.005" /><testcase classname="tests.test_utils" name="test_key_exists_yaml_value_is_null" time="0.006" /><testcase classname="tests.test_utils" name="test_config_caching" time="0.007" /><testcase classname="tests.test_utils" name="test_get_config_value_type_handling" time="0.008" /><testcase classname="tests.test_utils" name="test_setup_logging_basic_and_config[True]" time="0.006"><failure message="AssertionError: assert 'Logging setup complete.' in ''&#10; +  where '' = &lt;_pytest.logging.LogCaptureFixture object at 0x00000205E9C05F10&gt;.text">mock_get_config = &lt;MagicMock name='get_config_value' id='2224419783312'&gt;, caplog = &lt;_pytest.logging.LogCaptureFixture object at 0x00000205E9C05F10&gt;
tmp_path = WindowsPath('C:/Users/DRAGOHN/AppData/Local/Temp/pytest-of-DRAGOHN/pytest-8/test_setup_logging_basic_and_c0'), clear_handlers_first = True

    @pytest.mark.parametrize("clear_handlers_first", [True, False])
    @patch('utils.get_config_value')
    def test_setup_logging_basic_and_config(mock_get_config, caplog, tmp_path, clear_handlers_first):
        import utils # for _logging_configured
    
        # Ensure a clean slate for handlers if testing multiple scenarios
        root_logger_for_cleanup = logging.getLogger()
        if clear_handlers_first and root_logger_for_cleanup.hasHandlers():
            for handler in root_logger_for_cleanup.handlers[:]: # Iterate over a copy
                handler.close()
                root_logger_for_cleanup.removeHandler(handler)
    
        utils._logging_configured = False # Force re-run
    
        log_file_path = tmp_path / "test_app.log"
        def side_effect_get_config(key, default):
            if key == "logging.log_file": return str(log_file_path)
            if key == "logging.console_level": return "INFO"
            if key == "logging.file_level": return "DEBUG"
            return default # Should not be called for these keys in this test
        mock_get_config.side_effect = side_effect_get_config
    
        with caplog.at_level(logging.DEBUG):
            setup_logging()
    
        root_logger = logging.getLogger()
        assert len(root_logger.handlers) == 2
    
        console_handler = next((h for h in root_logger.handlers if isinstance(h, logging.StreamHandler)), None)
        file_handler = next((h for h in root_logger.handlers if isinstance(h, logging.handlers.RotatingFileHandler)), None)
    
        assert console_handler is not None, "Console handler not found"
        assert file_handler is not None, "File handler not found"
    
        assert console_handler.level == logging.INFO
        assert file_handler.level == logging.DEBUG
        assert file_handler.baseFilename == str(log_file_path)
        assert log_file_path.exists()
    
&gt;       assert "Logging setup complete." in caplog.text
E       AssertionError: assert 'Logging setup complete.' in ''
E        +  where '' = &lt;_pytest.logging.LogCaptureFixture object at 0x00000205E9C05F10&gt;.text

tests\test_utils.py:368: AssertionError</failure></testcase><testcase classname="tests.test_utils" name="test_setup_logging_basic_and_config[False]" time="0.006"><failure message="AssertionError: assert 'Logging setup complete.' in ''&#10; +  where '' = &lt;_pytest.logging.LogCaptureFixture object at 0x00000205E3C277D0&gt;.text">mock_get_config = &lt;MagicMock name='get_config_value' id='2224316138640'&gt;, caplog = &lt;_pytest.logging.LogCaptureFixture object at 0x00000205E3C277D0&gt;
tmp_path = WindowsPath('C:/Users/DRAGOHN/AppData/Local/Temp/pytest-of-DRAGOHN/pytest-8/test_setup_logging_basic_and_c1'), clear_handlers_first = False

    @pytest.mark.parametrize("clear_handlers_first", [True, False])
    @patch('utils.get_config_value')
    def test_setup_logging_basic_and_config(mock_get_config, caplog, tmp_path, clear_handlers_first):
        import utils # for _logging_configured
    
        # Ensure a clean slate for handlers if testing multiple scenarios
        root_logger_for_cleanup = logging.getLogger()
        if clear_handlers_first and root_logger_for_cleanup.hasHandlers():
            for handler in root_logger_for_cleanup.handlers[:]: # Iterate over a copy
                handler.close()
                root_logger_for_cleanup.removeHandler(handler)
    
        utils._logging_configured = False # Force re-run
    
        log_file_path = tmp_path / "test_app.log"
        def side_effect_get_config(key, default):
            if key == "logging.log_file": return str(log_file_path)
            if key == "logging.console_level": return "INFO"
            if key == "logging.file_level": return "DEBUG"
            return default # Should not be called for these keys in this test
        mock_get_config.side_effect = side_effect_get_config
    
        with caplog.at_level(logging.DEBUG):
            setup_logging()
    
        root_logger = logging.getLogger()
        assert len(root_logger.handlers) == 2
    
        console_handler = next((h for h in root_logger.handlers if isinstance(h, logging.StreamHandler)), None)
        file_handler = next((h for h in root_logger.handlers if isinstance(h, logging.handlers.RotatingFileHandler)), None)
    
        assert console_handler is not None, "Console handler not found"
        assert file_handler is not None, "File handler not found"
    
        assert console_handler.level == logging.INFO
        assert file_handler.level == logging.DEBUG
        assert file_handler.baseFilename == str(log_file_path)
        assert log_file_path.exists()
    
&gt;       assert "Logging setup complete." in caplog.text
E       AssertionError: assert 'Logging setup complete.' in ''
E        +  where '' = &lt;_pytest.logging.LogCaptureFixture object at 0x00000205E3C277D0&gt;.text

tests\test_utils.py:368: AssertionError</failure></testcase><testcase classname="tests.test_utils" name="test_setup_logging_invalid_config_types" time="0.033" /><testcase classname="tests.test_utils" name="test_get_typed_config_value_logic" time="0.006"><failure message="assert 'Could not convert' not in &quot;DEBUG    utils:utils.py:148 Could not convert 'still-not-an-int' for 'test.bad_int' to int (previously warned). Using default: 99\n&quot;&#10;  &#10;  'Could not convert' is contained here:&#10;    DEBUG    utils:utils.py:148 Could not convert 'still-not-an-int' for 'test.bad_int' to int (previously warned). Using default: 99&#10;  ?                             +++++++++++++++++">mock_get_raw_config = &lt;MagicMock name='get_config_value' id='2224316928080'&gt;, caplog = &lt;_pytest.logging.LogCaptureFixture object at 0x00000205E39EF610&gt;

    @patch('utils.get_config_value') # Mock the underlying get_config_value
    def test_get_typed_config_value_logic(mock_get_raw_config, caplog):
        import utils # For _warned_type_conversion_failures
        utils._warned_type_conversion_failures.clear()
    
        # Correct type, no conversion needed
        mock_get_raw_config.return_value = 123
        assert get_typed_config_value("test.int", 0, int) == 123
        mock_get_raw_config.assert_called_with("test.int", 0)
    
        mock_get_raw_config.return_value = "hello"
        assert get_typed_config_value("test.str", "default", str) == "hello"
    
        # Bool is not int/float if target is int/float (specific check in get_typed_config_value)
        mock_get_raw_config.return_value = True
        assert get_typed_config_value("test.bool_to_int", 0, int) == 1 # bool(True) -&gt; 1
    
        mock_get_raw_config.return_value = False # Direct bool
        assert get_typed_config_value("test.direct_bool", True, bool) is False
    
        # Conversion needed
        mock_get_raw_config.return_value = "456" # String to int
        assert get_typed_config_value("test.str_to_int", 0, int) == 456
    
        mock_get_raw_config.return_value = "1.23" # String to float
        assert get_typed_config_value("test.str_to_float", 0.0, float) == 1.23
    
        # String to bool: relies on bool() constructor behavior
        mock_get_raw_config.return_value = "true" # bool("true") is True
        assert get_typed_config_value("test.str_true_to_bool", False, bool) is True
        mock_get_raw_config.return_value = "false" # bool("false") is True
        assert get_typed_config_value("test.str_false_to_bool", False, bool) is True
        mock_get_raw_config.return_value = "" # bool("") is False
        assert get_typed_config_value("test.str_empty_to_bool", True, bool) is False
    
        # Conversion failure
        mock_get_raw_config.return_value = "not-an-int"
        with caplog.at_level(logging.WARNING):
            assert get_typed_config_value("test.bad_int", 99, int) == 99 # Default
        assert "Could not convert configured value 'not-an-int' for key 'test.bad_int' to int" in caplog.text
        assert ("test.bad_int", "int") in utils._warned_type_conversion_failures
        caplog.clear()
    
        # Conversion failure - warn only once
        mock_get_raw_config.return_value = "still-not-an-int" # Same key, different raw value
        assert get_typed_config_value("test.bad_int", 99, int) == 99
&gt;       assert "Could not convert" not in caplog.text # Not logged as warning again
E       assert 'Could not convert' not in "DEBUG    utils:utils.py:148 Could not convert 'still-not-an-int' for 'test.bad_int' to int (previously warned). Using default: 99\n"
E         
E         'Could not convert' is contained here:
E           DEBUG    utils:utils.py:148 Could not convert 'still-not-an-int' for 'test.bad_int' to int (previously warned). Using default: 99
E         ?                             +++++++++++++++++

tests\test_utils.py:468: AssertionError</failure></testcase><testcase classname="tests.test_utils" name="test_load_config_env_override_for_config_file_path" time="0.009" /></testsuite></testsuites>
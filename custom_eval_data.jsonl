{"task_id": "baby_codegen_001", "task_type": "code_generation", "stage": "baby", "prompt": "Write a Python function called `add` that takes two numbers and returns their sum.", "unit_tests": "assert add(1, 2) == 3\nassert add(-5, 5) == 0\nassert add(0, 0) == 0", "task_version": "1.0", "source_origin": "Manual creation for basic arithmetic"}
{"task_id": "baby_concept_001", "task_type": "concept_explanation", "stage": "baby", "prompt": "Explain what a variable is in Python in simple terms.", "reference_text": ["A variable in Python is like a container that holds a value. You can give it a name and store different kinds of information in it, like numbers or words.", "In Python, a variable is a named storage location for data. Think of it as a label you put on a box to know what's inside.", "Variables are used to store information that can be referenced and manipulated in a computer program."], "task_version": "1.1", "source_origin": "Manual creation for fundamental programming concepts"}
{"task_id": "toddler_docstring_001", "task_type": "docstring_generation", "stage": "toddler", "prompt": "Generate a concise docstring for the following Python function.", "reference_code": "def greet(name):\n    return f\"Hello, {name}!\"", "reference_text": ["\"\"\"Greets a person by their name.\n\nArgs:\n    name (str): The name of the person to greet.\n\nReturns:\n    str: A greeting message.\n\"\"\""], "task_version": "1.0", "source_origin": "Manual creation for basic function documentation"}
{"task_id": "toddler_explain_001", "task_type": "code_explanation", "stage": "toddler", "prompt": "Explain what this Python code does, focusing on the list comprehension.", "reference_code": "numbers = [1, 2, 3, 4, 5]\nsquares = [n**2 for n in numbers if n % 2 == 0]\nprint(squares)", "reference_text": ["This code first defines a list of numbers. Then, it uses a list comprehension to create a new list called `squares`. The list comprehension iterates through the `numbers` list, and for each even number (`n % 2 == 0`), it calculates its square (`n**2`) and adds it to the `squares` list. Finally, it prints the `squares` list, which will contain the squares of the even numbers from the original list.", "The code snippet initializes a list of integers. It then employs a list comprehension to generate a new list, `squares`, containing the square of each even number found in the `numbers` list. The `squares` list is then printed."], "task_version": "1.0", "source_origin": "Manual creation for list comprehensions"}
{"task_id": "teenager_codegen_001", "task_type": "code_generation", "stage": "teenager", "prompt": "Write a Python class `Rectangle` with a constructor that accepts `width` and `height`, and methods `area()` and `perimeter()`.", "unit_tests": "r1 = Rectangle(10, 5)\nassert r1.area() == 50\nassert r1.perimeter() == 30\nr2 = Rectangle(7, 7)\nassert r2.area() == 49\nassert r2.perimeter() == 28", "task_version": "1.0", "source_origin": "Manual creation for OOP basics"}
{"task_id": "teenager_concept_001", "task_type": "concept_explanation", "stage": "teenager", "prompt": "Explain Python decorators and provide a simple use case.", "reference_text": ["Python decorators are a way to modify or enhance functions or methods in a clean, readable way. They are a form of metaprogramming where a part of the program tries to modify another part of the program at compile time. A decorator is a callable that takes another function as an argument (the decorated function) and returns a new function that usually extends or modifies the behavior of the original function. A simple use case is a timing decorator that measures the execution time of a function.", "Decorators in Python provide a syntactic sugar to wrap a function or method with another function. This wrapper function can execute code before or after the original function call, or even replace the original function entirely. For example, a decorator can be used to log function calls, add security checks, or implement caching."], "task_version": "1.0", "source_origin": "Manual creation for intermediate Python features"}
{"task_id": "nostage_codegen_001", "task_type": "code_generation", "prompt": "Write a Python function `is_palindrome` that checks if a string is a palindrome. It should ignore case and non-alphanumeric characters.", "unit_tests": "assert is_palindrome('Racecar!') == True\nassert is_palindrome('A man, a plan, a canal: Panama') == True\nassert is_palindrome('hello') == False\nassert is_palindrome('') == True\nassert is_palindrome('No lemon, no melon.') == True", "task_version": "1.0", "source_origin": "Manual creation for string manipulation"}
{"task_id": "adult_concept_001", "task_type": "concept_explanation", "stage": "adult", "prompt": "Explain the Global Interpreter Lock (GIL) in CPython and its implications for multi-threaded performance.", "reference_text": ["The Global Interpreter Lock (GIL) in CPython is a mutex that protects access to Python objects, preventing multiple native threads from executing Python bytecodes at once. This lock is necessary because CPython's memory management is not thread-safe. As a result, even on multi-core processors, only one thread can hold control of the Python interpreter at any given time, which can limit the performance of CPU-bound multi-threaded Python programs. For I/O-bound tasks, the GIL is often released, allowing other threads to run.", "CPython's GIL is a lock that allows only one thread to execute Python bytecode at a time. This simplifies CPython's implementation and memory management but means that CPU-bound Python programs using threads cannot achieve true parallelism on multi-core machines. I/O-bound threads, however, can benefit from threading as the GIL is typically released during I/O operations."], "task_version": "1.0", "source_origin": "Manual creation for advanced Python internals"}
{"task_id": "adult_codegen_001", "task_type": "code_generation", "stage": "adult", "prompt": "Implement a basic asynchronous web scraper using Python's asyncio and aiohttp libraries to fetch the titles of the first 3 URLs from a given list. Handle potential request errors gracefully.", "unit_tests": "import asyncio\nasync def mock_fetch(session, url):\n    if 'valid1' in url: return '<title>Valid Page 1</title>'\n    if 'valid2' in url: return '<title>Valid Page 2</title>'\n    if 'error' in url: raise Exception('Simulated error')\n    return ''\nasync def main_test():\n    urls = ['http://valid1.com', 'http://error.com', 'http://valid2.com', 'http://valid3.com']\n    # This test would require more setup to mock aiohttp.ClientSession effectively.\n    # For now, we'll assert a placeholder. A real test would check the output of the scraper.\n    # titles = await scrape_titles(urls) # Assuming the function is named scrape_titles\n    # assert 'Valid Page 1' in titles\n    # assert 'Valid Page 2' in titles\n    # assert len(titles) == 2 # or 3 if errors are handled by returning None/empty\n    assert True # Placeholder for more complex async test\nasyncio.run(main_test())", "task_version": "1.0", "source_origin": "Manual creation for advanced async programming"}

